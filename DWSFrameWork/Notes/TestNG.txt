TestNG:
=========

> actually a unit testing tool/framework used by Developers to test each and every line of the code
> Test Next Generation

---> JUnit --> java
---> NUnit --> .Net/C#
---> PTest --> python

---> TestNG --> Upgraded version of JUnit and NUnit

Why it is used in Automation ?
-------------------------------
 
Scenario : 100 scripts---> difficulty
---> single click multiple test scripts execution
---> filtering multiple test scripts
---> parallel execution of scripts
---> cross browser execution of scripts

we have advantages if we use TestNg framework:
===================================================
> batch execution
> parallel execution
> group execution
> report generation
> cross browser exeution

Installation ways:
---------------------
> Eclipse market place
> Install New Software
> Maven Dependency
> TestNg jar

First and ForeMost rule:
===========================
--> main(String[] args) ----->not recommended
--> non static methods(convention) with @Test Annotation -----> recommended


--> A class which is having atleast 1 @Test , we can specify it as TestNg Classes
--> A method which is having @Test are called as TestCase.
--> Statements inside the @Test method are called as TestSteps.

import org.testng.Reporter;
import org.testng.annotations.Test;

public class Demo {						--> TestNg class
	@Test
	public void executeScript() {				--> TestCase
		//System.out.println("TestNg method");
		Reporter.log("TestNg method",true);		--> Test steps
	}
}

Reporter.log():
===============

If you want to log a msg in the Report generated by TestNg , we have to use log(String s) method which is present in Reporter class of TestNg

Reporter.log(String s);
Reporter.log("your msg");

Reporter.log(String s, boolean logToStandardOut)
Reporter.log("your msg",true);--> Console


You can have 'n' number of  @Test methods, in that case which method will execute First.

package com.learningTestNG;

import org.testng.Reporter;
import org.testng.annotations.Test;

public class Demo {
	@Test
	public void executeScript1() {
		//System.out.println("TestNg method");
		Reporter.log("TestNg method1",true);
	}
	
	@Test
	public void executeScript2() {
		//System.out.println("TestNg method");
		Reporter.log("TestNg method2",true);
	}
}


Execution order:

executeScript1()
executeScript2()
--> Alphabetical order

helperAttributes:
===================

priority:
===========
> when ever we have multiple testcase in a TestNG class we can use priority helper attribute
> priority accepts +ve and -ve integer
> by default priority will be Zero.
> if priority is same , again its runs based on Alphabetical order.
> it will execute script from the testcase having lower priority value to the higher

public class Class1 {
	@Test(priority = 1)
	public void test2() {	
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.selenium.dev/");
		Reporter.log("Selenium dev is opened",true);
		driver.close();
	}
	@Test(priority = 3)
	public void test1() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
	@Test(priority = 2)
	public void test3() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
	
	
}

execution order:
------------------
test2()
test3()
test1()


invocationCount:
==================
> when ever you wanna run a Testcase more than once you can use helper attribute invocationCount.
> it accepts integers, if you provide 5 testcase execute 5 times
> if you give -ve or zero it is not considered for execution
> default value of invocationCount for every testcase is 1


public class Class1 {
	@Test(invocationCount = 3)
	public void test2() {	
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.selenium.dev/");
		Reporter.log("Selenium dev is opened",true);
		driver.close();
	}
	@Test
	public void test1() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
}

execution order :
-------------------
test1()
test2()
test2()
test2()


threadPoolSize:
================
--> providing threads for executing your testcase to run multiple times parallelly.
--> threadPoolSize accepts integer, normally we will give it to the similar to invocationCount to run the testCase multiple times that too parallel.
--> by default threadPoolSize will be 1
--> don't use threadpoolsize without invocation count

public class Class1 {
	@Test(invocationCount = 3, threadPoolSize = 3)
	public void test2() {	
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.selenium.dev/");
		Reporter.log("Selenium dev is opened",true);
		driver.close();
	}
	@Test
	public void test1() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
}

In above example test2() will execute for 3 times parallelly

enabled:
=========
> if we don't wanna execute the testcase, we can have invocationCount = 0 or else we can use enabled = false
> it accepts boolean value
> if you provide false, it will not be considered for execution.


public class Class1 {
	@Test(enabled = false)
	public void test2() {	
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.selenium.dev/");
		Reporter.log("Selenium dev is opened",true);
		driver.close();
	}
	@Test
	public void test1() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
}

In above example test2() is disabled so it will be not considered for execution


dependsOnMethods:
==================
> if we have to depend on methods for execution of a particular testcase then we will go with dependsOnMethods helper attribute we can give 1 method or even multiple method and we can use it.
> here if we depend on other methods that methods will work first then the method which is depending will work
> dependsOnMethods="methodname" --> for single method dependency
> dependsOnMethods={"method1","method2"} --> for multiple method dependency

public class Class1 {
	@Test(dependsOnMethods = {"test1","test3"})
	public void test2() {
		
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.selenium.dev/");
		Reporter.log("Selenium dev is opened",true);
		driver.close();
	}
	@Test(priority = 3)
	public void test1() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
	@Test(priority = 2)
	public void test3() {
		System.out.println("TestNg1");
		ChromeDriver driver=new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.javatpoint.com/");
		driver.close();
	}
	
	
}


timeOut:
=========
> It accepts timeOut in long, we have to provide time in long format basically in millis.
> checks whether the testcase will be executed within the given time or not if its not executed within the specified time then it will consider test case as failure and throws ThreadTimeOutException

@Test(timeOut = 10000)
public void executeScript3() {
		Reporter.log("TestNg method3", true);
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.triumphmotorcycles.in/motorcycles/adventure/tiger-900");
		driver.quit();
}

-----------------------------------------------------------------------------------------------------

Batch Execution:
=================
> Execution of multiple scripts in one single click
> Select multiple testNg classes > right click > TestNg > Convert to TestNG
> An xml file gets created, if you run that xml file, it will execute all the testcases, sequential format.


---------------------------------------------------------------------------------------------------
public class R15 {
	@Test
	public void launchingR15Site() {
		Reporter.log("R15 website launching", true);
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.yamaha-motor-india.com/yamaha-r15v4.html");
		driver.quit();
	}
}

-----------------------------------------------------------------------------------------------------
public class HayaBusa {
	@Test
	public void launchingHayaBusaSite() {
		Reporter.log("HayaBusa website launching", true);
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.suzukimotorcycle.co.in/product-details/hayabusa");
		driver.quit();
	}
}

-------------------------------------------------------------------------------------------------------

public class Jawa {

	@Test
	public void launchBobber42() {
		Reporter.log("Bobber42 website launching", true);
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.jawamotorcycles.com/motorcycles/42-bobber");
		driver.quit();
	}
	
	@Test
	public void launchJawa350() {
		Reporter.log("Jawa350 website launching", true);
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://www.jawamotorcycles.com/motorcycles/jawa-350");
		driver.quit();
	}
}


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Suite">
  <test thread-count="5" name="Test">
    <classes>
      <class name="com.batchExecutionClasses.HayaBusa"/>
      <class name="com.batchExecutionClasses.Jawa"/>
      <class name="com.batchExecutionClasses.R15"/>
    </classes>
  </test> <!-- Test -->
</suite> <!-- Suite -->


----------------------------------------------------------------------------------------------------

Parallel Execution:
====================
> Execution of multiple scripts in one single click parallely
> Select multiple testNg classes > right click > TestNg > Convert to TestNG
> An xml file gets created, if you run that xml file, it will execute all the testcases, in parallel
> parallel attribute in test level or suite level and you can have attribue values --> tests, classes, methods, true
> note: number of testcases or testng classes getting invoked depends on Thread-count attribute at test level

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Suite">
  <test thread-count="10" name="Test" parallel="classes">
    <classes>
      <class name="com.ParallelExecutionClasses.HayaBusa"/>
      <class name="com.ParallelExecutionClasses.R15"/>
      <class name="com.ParallelExecutionClasses.Jawa"/>
    </classes>
  </test> <!-- Test -->
</suite> <!-- Suite -->


Group Execution:
=================
> Execution of Test Cases of Similar group is called as Group Execution
> in order to to this, we have to map each and every testcase for a particular group, you can do this with helper attribute called as groups, you can give any name, you can make a testcase available for multiple groups.
> generate your xml
>  you have to use <groups> tag after <test> and before <classes> as mentioned in below xml file
> inside groups use <run> tag inside that you can use include as well as exclude


public class Yash {
	
	@Test(groups = {"KFI","Pan India"})
	public void launchingWikipedia() {
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://en.wikipedia.org/wiki/Yash_(actor)");
		driver.quit();
		
	}
}
--------------------------------------------------------------------------------------------------------
public class AlluArjun {
	@Test(groups = {"TFI","Pan India"})
	public void launchingWikipedia() {
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://en.wikipedia.org/wiki/Allu_Arjun");
		driver.quit();
		
	}
}
--------------------------------------------------------------------------------------------------------
public class Puneeth {
	@Test(groups = "KFI")
	public void launchingWikipedia() {
		WebDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.get("https://en.wikipedia.org/wiki/Puneeth_Rajkumar");
		driver.quit();
		
	}
}

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Suite">
  <test thread-count="5" name="Test" >
	  <groups>
		  <run>
			  <include name="Pan India"></include>
			  <exclude name="TFI"></exclude>
		  </run>
	  </groups>
    <classes>
      <class name="com.GroupExecutionClasses.Yash"/>
      <class name="com.GroupExecutionClasses.Puneeth"/>
      <class name="com.GroupExecutionClasses.AlluArjun"/>
    </classes>
  </test> <!-- Test -->
</suite> <!-- Suite -->



CrossBrowserExecution:
==========================
> Executing TestCases in different browser by passing browser name using TestNg.xml file
> we can use a tag called as <parameter> tag in testng.xml file and we have to pass the data, as given below
> if yu want to pass parameter we have to use @Parameters annotation.
> if you are not passing parameter, still i want to launch in a particular browser as optional we can use @Optional(browserName) in method header.
> to pass paramaters we have to Write @Parameters("bname") above the method



public class TestScript1 {
	@Parameters("bname")
	@Test
	public void launchGoIndigo(@Optional("chrome") String browserName) {
		WebDriver driver = null;
		if (browserName.equalsIgnoreCase("chrome")) {
			driver = new ChromeDriver();
		} else if (browserName.equalsIgnoreCase("firefox")) {
			driver = new FirefoxDriver();
		} else if (browserName.equalsIgnoreCase("edge")) {
			driver = new EdgeDriver();
		}
		driver.manage().window().maximize();
		driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(15));
		driver.get("https://www.goindigo.in/");
	}
}


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Suite">
	<parameter name="bname" value="firefox"></parameter>
  <test thread-count="5" name="Test">
    <classes>
      <class name="com.CrossBrowserExecution.TestScript1"/>
    </classes>
  </test> <!-- Test -->
</suite> <!-- Suite -->

> we have to use <parameter name="bname" value="chrome">


--------------------------------------------------------------------------------------------------------

basic structure of testng xml file :
----------------------------------------
<suite>
	<test>
		<classes>
			<class>
				<method></method>
				<method></method>
			</class>
			<class>
				<method></method>
			</class>
		</classes>
	</test>
</suite>
 

Configuration Annotation:
============================

@BeforeSuite
	@BeforeTest
		@BeforeClass
			@BeforeMethod
					@Test
			@AfterMethod
		@AfterClass
	@AfterTest
@AfterSuite


--> chronological order

@BeforeSuite:
==============
> here we will write code for creating connection using JDBC and configuring reports

@AfterSuite:
=============
> we will close the connection of DB and flush all the reports


@BeforeTest:
==============
> we can write preconditions given in requirements

@AfterTest:
=============
> we can write postconditions given in requirements

@BeforeClass:
==============
> we will write code to lauch the browser , maximize it and load url.

@AfterClass:
============
> we will crite code to close the browser as well as driver session

@BeforeMethod:
===============
> we will write code to perform login

@AfterMethod:
===============
> we will write code to perform logout.


Adding TestNg to Project
===========================
Select your Project > rightclick > Buildpath > configure Build path > Libraries section > select class path > click on Add Library  > double click on TestNg > finish

Dataprovider : 

An advance concept of testNg where we can execute a TestScript for multiple times with different data's, 
> we are using set of Test datas need to be executed on a script in our excel sheet
> we will use one annotation called as @DataProvider to take the data's row by row and execute the same testcase based on the set of test data's available in that excel file.
> data provider is responsible to drive the test case for multiple times

> refer below code to understand data provider. 

Desigining dataprovider :
================================

public class DataProviderClass {
	@DataProvider
	public String[][] dataProviderMethod() {
		File f = new File(".\\test-data\\DWS.xlsx");
		Workbook workbook=null;
		try {
		FileInputStream fis=new FileInputStream(f);
		workbook = WorkbookFactory.create(fis);
		}
		catch(Exception e) {
			
		}
		Sheet sheet = workbook.getSheet("Sheet1");
		int rowCount = sheet.getPhysicalNumberOfRows();
		int cellCount = sheet.getRow(0).getPhysicalNumberOfCells();
		String[][] result= new String[rowCount-1][cellCount];
		for(int i=1;i<rowCount;i++) {
			for(int j=0;j<cellCount;j++) {
				String data=sheet.getRow(i).getCell(j).toString();
				result[i-1][j]=data;
			}
		}
		return result;
	}
}


using it in a Register script
------------------------------


public class RegisterUsingDataProvider {
	@Test(dataProvider = "dataProviderMethod", dataProviderClass = genericUtils.DataProviderClass.class)
	public void register(String firstname, String lastname, String email, String password) {
		ChromeDriver driver = new ChromeDriver();
		driver.manage().window().maximize();
		driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(15));
		driver.get("https://demowebshop.tricentis.com/");
		driver.findElement(By.linkText("Register")).click();
		driver.findElement(By.id("gender-male")).click();
		driver.findElement(By.id("FirstName")).sendKeys(firstname);
		driver.findElement(By.id("LastName")).sendKeys(lastname);
		driver.findElement(By.id("Email")).sendKeys(email);
		driver.findElement(By.id("Password")).sendKeys(password);
		driver.findElement(By.id("ConfirmPassword")).sendKeys(password);
		driver.findElement(By.xpath("//input[@value='Register']")).click();
	}
}

-------------------------------------------------------------------------------------------------------------


Assertion:
============
	It is one of the advance mechanism in TestNg which is used to validate or performing verification

2 types:
---------
1. Assert (HardAssert)
2. SoftAssert

Drawbacks of Using if and else for validation:
------------------------------------------------
> if else consumes more lines of code
> if else will not stop the execution if there is a problem in validation
> proper error will not be recorded.


Assert: (HardAssert)
=========
> It is a class, with static methods'
> assertEquals(actualData, expectedData, [String errormsg])
> assertTrue(boolean result, [String errormsg])



public class TestScript1 extends BaseClass{
	@Test
	public void clickOnElectronicsLink() {
		String expectedtitleOfElectronicspage="Demo Web Shop. Electronics";
		driver.findElement(By.partialLinkText("Electronics")).click();
		Assert.assertEquals(driver.getTitle(),expectedtitleOfElectronicspage,"Electronics Page not Found!!!");;
		//Assert.assertTrue(driver.getTitle().equals(expectedtitleOfElectronicspage),"Electronics Page not Found!!!");
		driver.findElement(By.partialLinkText("Cell phones")).click();
	}
}


SoftAssert:
==============
> It is class, with non static methods
> assertEquals(actualData, expectedData, [String errormsg])
> assertTrue(boolean result, [String errormsg])
> assertAll() --> mandatory at the last

--------------------------------------------------------------------------------------------------------
public class TestScript1 extends BaseClass{
	@Test
	public void clickOnElectronicsLink() {
		String expectedtitleOfElectronicspage="Demo Web Shop. Electronics";
		driver.findElement(By.partialLinkText("Electronics")).click();
		Assert.assertEquals(driver.getTitle(),expectedtitleOfElectronicspage,"Electronics Page not Found!!!");;
		//Assert.assertTrue(driver.getTitle().equals(expectedtitleOfElectronicspage),"Electronics Page not Found!!!");
		driver.findElement(By.partialLinkText("Cell phones")).click();
		driver.findElement(By.xpath("//a[text()='Smartphone']/../..//input[@value='Add to cart']")).click();
		String expectedAddToCartMsg="The product is been added to your shopping cart";
		WebElement notification = driver.findElement(By.className("content"));
		SoftAssert softassert=new SoftAssert();
		softassert.assertEquals(notification.getText(), expectedAddToCartMsg,"not matching with expected");
		System.out.println("****************");
		System.out.println("not stopped");
		softassert.assertAll();
	}
}
-------------------------------------------------------------------------------------------------------------

HardAssert: If something validation is fail you should not execute further
SoftAssert: If something validation is failed, but not that much important, i can continue my execution later i can see fail validation statements


Assert						|		SoftAssert
------------------------------------------------|-------------------------------------------------
> methods are static 				|    > methods are non static
> it will stop execution 			|    > it will never stop execution
> no need of calling assertAll()		|    > it is mandatory to call assertAll() at the last



Listners In TestNG:
=====================

> Listners are the advance mechanism given by the testNg framework, to listen (track) the testscripts

> particularly we are going to learn ITestListeners

This is the most frequently used TestNG listener. ITestListener is an interface implemented in the class, and that class overrides the ITestListener-defined methods. The ITestListener listens to the desired events and executes the methods accordingly.

It contains the following ways:

1. onTestStart(ITestResult result):
========================================
	It will be triggered automatically when testCase is started, we can given implementation want we wanted to perform on testcase start

2. onTestSuccess(ITestResult result):
=========================================
	It will be triggered automatically when testCase is successfully executed, we can given implementation want we wanted to perform on testcase success

3. onTestFailure(ITestResult result):
===========================================
	It will be triggered automatically when testCase is failed, we can given implementation want we wanted to perform on testcase failure, generally we will take Screenshots

4. onTestSkipped(ITestResult result):
===========================================
	It will be triggered automatically when testCase is skipped, we can given implementation want we wanted to perform on testcase skips

5. onStart(ITestContext context):
==================================
	It will be triggered automatically when <test> is started its execution, we can given implementation want we wanted to perform on <test> start

6. onFinish(ITestContext context):
===================================
	It will be triggered automatically when <test> is ended its execution, we can given implementation want we wanted to perform on <test> ended.



public class BaseClass implements IAutoConstants, ITestListener{

	public static WebDriver driver;
	public FileLibrary flib;
	public BasePage bp;
	public LoginPage lp;
	
	@BeforeSuite
	public void beforeSuite() {
		Reporter.log("Before Suite", true);
	}
	@BeforeTest
	public void beforeTest() {
		Reporter.log("Before Test", true);
	}
	@AfterSuite
	public void afterSuite() {
		Reporter.log("After Suite", true);
	}
	@AfterTest
	public void afterTest() {
		Reporter.log("After Test", true);
	}
	@Parameters("bname")
	@BeforeClass
	public void launchingBrowser(@Optional("chrome") String browserName) {
		
		Reporter.log("Before class", true);
		if(browserName.equalsIgnoreCase("chrome"))
			driver=new ChromeDriver();
		else if(browserName.equalsIgnoreCase("edge"))
			driver=new ChromeDriver();
		else if(browserName.equalsIgnoreCase("firefox"))
			driver=new ChromeDriver();
		bp = new BasePage(driver);
		lp = new LoginPage(driver);
		flib =new FileLibrary();
		driver.manage().window().maximize();
		driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitTimeOut));
	}
	@AfterClass
	public void tearDownBrowser() {
		Reporter.log("After class", true);
		driver.close();
		driver.quit();
	}
	@BeforeMethod
	public void navigateAndLoginToDWS() {
		Reporter.log("Before method", true);
		driver.get(flib.fetchDataFromProperties(propertyFilePath, "url"));
		lp.getLoginLink().click();
		lp.getEmailTextBox().sendKeys(flib.fetchDataFromProperties(propertyFilePath, "email"));
		lp.getPasswordTextBox().sendKeys(flib.fetchDataFromProperties(propertyFilePath, "password"));
		lp.getLoginButton().click();
		
	}
	@AfterMethod
	public void afterMethod() {
		Reporter.log("After method", true);
		lp.getLogoutLink().click();
	}
	
	@Override
	public void onTestStart(ITestResult result) {
		Reporter.log("[ Testcase --"+result.getName()+"-- is started]");
	}
	@Override
	public void onTestSuccess(ITestResult result) {
		Reporter.log("[ Testcase --"+result.getName()+"-- is passed]");
	}
	@Override
	public void onTestFailure(ITestResult result) {
		Reporter.log("[ Testcase --"+result.getName()+"-- is failed]");
		LocalDateTime ldt=LocalDateTime.now();
		String time=ldt.toString().replace(":", "-");
		TakesScreenshot ts =(TakesScreenshot)driver;
		File src=ts.getScreenshotAs(OutputType.FILE);
		File dest = new File(screenshotpath+"screenshot"+time+".png");
		try {
			FileHandler.copy(src, dest);
		} catch (Exception e) {
			
		}
	}
	@Override
	public void onTestSkipped(ITestResult result) {
		Reporter.log("[ Testcase --"+result.getName()+"-- is skipped]");
	}
	@Override
	public void onStart(ITestContext context) {
		Reporter.log("[ <test> --"+context.getName()+"-- is started]");
	}
	@Override
	public void onFinish(ITestContext context) {
		Reporter.log("[ <test> --"+context.getName()+"-- is finished]");
	}
	
	
}
